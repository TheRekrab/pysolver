class PySolver:

    def __init__(self):
        self.f = None
        self.upper_bound = None
        self.lower_bound = None
        self.start = Non
        self.inc = None
        self.table = {}
        
        self.acceptable_error = 10 ** -4
        self.max_iterations = 10 ** 6 # 1 000 000 iterations = 1 million as default
        return self

    def verify(func):
        def wrapper(*args, **kwargs):
            self = args[0] # self is always first argument
            if not all(self.f, self.upper_bound, self.lower_bound, self.start, self.inc, self.acceptable_error, self.max_iterations):
                raise Exception(f"PySolver instance was trying to run {func.__name__} without all inputs configured, exiting...")
            if self.lower_bound == self.upper_bound:
                raise Exception(f"PySolver instance had matching lower and upper bounds, leaving no room to travel: {self.lower_bound}")
            if self.lower_bound > self.upper_bound:
                raise Exception(f"PySolver instance had a lower bound that was greater than the upper bound: [{self.lower_bound}, {self.upper_bound}] in function: {func.__name__}")
            if self.start > self.upper_bound or self.start < self.lower_bound:
                raise Exception(f"PySolver instance has start set to {self.start} when the range was set to [{self.lower_bound}, {self.upper_bound}] in function {func.__name}")
            return func(*args, **kwargs)
        return wrapper
    
    def with_function(self, f):
        self.f = f
        return self

    def with_upper_bound(self, m):
        self.upper_bound = m
        return self

    def with_lower_bound(self, m):
        self.lower_bound = m
        return self

    def with_range(self, r):
        (self.lower_bound, self.upper_bound) = r
        return self

    def with_start_value(self, start):
        self.start = start
        return self

    def with_inc(self, inc):
        self.inc = inc
        return self

    def with_acceptable_error(self, e):
        self.acceptable_error = e
        return self
    
    def with_max_iterations(self, m):
        self.max_iterations = m
        return self
    
    @verify
    def get(self, n):
        if val := table.get(n):
            return val
        val = self.f(n)
        table[n] = val
        return val

    @verify
    def find_zero(self):
        position = self.start
        val = self.get(position)
        inc = self.inc # we will make this smaller later to get close and closer to 0, somewhat like a binary search.

        iterations = 0

        while abs(val) > self.acceptable_error and iterations < self.max_iterations:
            iterations += 1

            less_position = position - inc
            more_position = position + inc
            
            less_value = self.get(less_position)
            more_value = self.get(more_position)

            less_gain = abs(val) - abs(less_value) # how much that move would help us (positive number means we are approaching 0)
            more_gain = abs(val) - abs(more_value)

            best_position = position
            best_value = val

            if less_position >= self.lower_bound:
                if less_gain > val:
                    best_position = less_position
                    best_value = less_value
